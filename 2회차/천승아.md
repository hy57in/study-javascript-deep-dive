# ✍️ 공부 내용 정리

## 10장 객체 리터럴

### 10-1. 객체란?

1. JS는 객체 기반 프로그래밍 언어

- 원시 타입: 단 하나의 값만 나타냄, 변경 불가
- 객체 타입: 다양한 타입의 값을 하나의 단위로 구성한 자료구조, 변경 가능한 값

2. 객체 구성: 프로퍼티 키, 프로퍼티 값 -> 프로퍼티의 집합

- 모든 값은 프로퍼티 값이 될 수 있음
- 프로퍼티 값이 함수일 경우 메서드

```js
var counter = {
  // 프로퍼티: 객체의 상태를 나타내는 값
  num: 0,
  // 메서드: 프로퍼티를 참조하고 조작할 수 있는 동작
  increase: function () {
    this.num++;
  },
};
```

### 10-2. 객체 리터럴에 의한 객체 생성

1. 클래스 기반 객체지향 언어

- 사전에 클래스를 생성하고 new + 생성자로 인스턴스 생성하는 방식으로 객체 생성
- C++, JAVA

2. 프로토타입 기반 객체지향 언어 (JS)

- 다양한 객체 생성 방법 지원
  - 객체 리터럴: 가장 기본적, 유연하고 강력함, new 연산자 + 생성자 X, 동적 프로퍼티 추가 등..
  - (Object) 생성자 함수, Object.create, 클래스 ..

3. 변수 할당 시점에 객체 리터럴이 해석되어 객체를 생성함

### 10-3. 프로퍼티

- 프로퍼티 키: 모든 문자열 또는 심벌 값
  - 빈 문자열 포함 but 키의 역할을 하지 못함
  - 암묵적 타입 변환으로 문자열이 됨
  - 중복 키 선언 시 에러 발생하지 않고 기존 프로퍼티를 덮어씀
- 프로퍼티 값: 자바스크립트에서 사용할 수 있는 모든 값

### 10-4. 메서드

함수는 객체 -> 함수는 값 -> 프로퍼티 값 사용 가능 -> 메서드: 객체에 묶여있는 함수

```js
var circle = {
  radius: 5, // ← 프로퍼티

  // 원의 지름
  getDiameter: function () {
    // ← 메서드
    return 2 * this.radius; // this는 circle을 가리키는 참조변수
  },
};

console.log(circle.getDiameter()); // 10
```

### 10-5. 프로퍼티 접근

- 객체에 존재하지 않는 key 접근 시 `undefined` 반환, ReferenceError 발생 X

### 10-8. 프로퍼티 삭제

- `delete` 연산자: 존재하지 않는 프로퍼티 삭제 시 에러 없이 무시됨

### 10-9. 객체 리터럴 확장 기능

- 프로퍼티 키 동적 생성

  1. ES5 이전: 객체 외부에서 프로퍼티 키 동적 생성
  2. ES6 이후: 객체 내부에서 프로퍼티 키 동적 생성 가능

- 메서드 축약 표현
  1. ES5 이전: 메서드 정의 시 프로퍼티 값으로 함수 할당
  2. ES6 이후: 메서드 정의 시 function 생략 가능 -> 프로퍼티에 할당한 함수와 다르게 동작함

```js
// ES6
const obj = {
  name: "Lee",
  // 메서드 축약 표현
  sayHi() {
    console.log("Hi! " + this.name);
  },
};

obj.sayHi(); // Hi! Lee
```

---

## 11장 원시 값과 객체의 비교

원시 값과 객체는 크게 세 가지 측면에서 다르다 -> 변경 여부, 메모리 공간에 저장되는 값, 변수 할당 시 전달되는 형태

### 11-1. 원시 값

1. 변경 불가능한 값 (읽기 전용)

- 데이터의 신뢰성 보장
- 값의 불변성
  - 원시 값을 할당한 변수에 원시 값을 재할당하면 -> 원시 값은 변경 불가능하므로, 새로운 메모리 공간 확보하여 값을 저장한 후 변수에 새롭게 할당한 원시 값을 가리킴 (메모리 공간 주소를 바꿈)
  - 만약 변경 가능하다면, 주소는 그대로고 주소 안의 값이 변경되었을 것 -> 즉 원시 값을 할당한 변수는 재할당이 변수 값을 변경하는 유일한 방법

2. 문자열과 불변성

- JS에서 문자열은 원시 타입이며 변경 불가함.
- 문자열은 유사 배열 객체 및 이터러블 -> 배열과 유사하게 각 문자에 접근할 수 있지만 변경 불가

```js
var str = "string";

// 문자열은 유사 배열이므로 배열과 유사하게 인덱스를 사용해 각 문자에 접근할 수 있다.
// 하지만 문자열은 원시값이므로 변경할 수 없다. 이때 에러가 발생하지 않는다.
str[0] = "S";

console.log(str); // string
```

3. 값에 의한 전달

- 변수에 원시 값 변수를 할당 시 할당 되는 원시 값이 복사되어 전달 -> 값에 의한 전달
- 변수들은 같은 값을 가지나, 값은 서로 다른 메모리에 저장된 별개의 값임. **할당 후 서로 영향을 주지 않음**
- 엄밀히 하자면 메모리 주소가 전달되는 것!

```js
var score = 80;

// copy 변수에는 score 변수의 값 80이 복사되어 할당된다.
var copy = score;

console.log(score, copy); // 80  80
console.log(score === copy); // true

// score 변수와 copy 변수의 값은 다른 메모리 공간에 저장된 별개의 값이다.
// 따라서 score 변수의 값을 변경해도 copy 변수의 값에는 어떠한 영향도 주지 않는다.
score = 100;

console.log(score, copy); // 100  80
console.log(score === copy); // false
```

### 11-2. 객체

- 원시 값처럼 메모리 공간 크기 사전 정의 불가: 프로퍼티가 동적이므로
- 객체 생성 및 관리는 복잡하고 비용이 많이 들어 변경 가능한 값으로 설계하여 단점을 완화시킴
  - 여러 개의 식별자가 하나의 객체 공유 가능해서 부작용할 수 있음

1. 변경 가능한 값

- 객체(참조) 타입의 값은 변경 가능함
- 원시 값 할당 변수의 메모리 주소를 따라가면 원시 값 자체를 값으로 가짐
- 객체 값 할당 변수의 메모리 주소를 따라가면 참조 값에 접근함 -> 그 값이 저장되어 있는 주소를 가짐 -> 참조하여 실제 객체에 접근
- 재할당 없이 프로퍼티 동적 추가, 삭제, 변경 가능 -> 변수의 참조 값은 변경되지 않음

```js
/**
 * - 얕은 복사: 한 단계까지 복사 (원시 값)
 * - 깊은 복사: 중첩된 객체까지 모두 복사본을 만듦 (객체)
 */

const o = { x: { y: 1 } };

// 얕은 복사
const c1 = { ...o }; // 35장 "스프레드 문법" 참고
console.log(c1 === o); // false
console.log(c1.x === o.x); // true

// lodash의 cloneDeep을 사용한 깊은 복사
// "npm install lodash"로 lodash를 설치한 후, Node.js 환경에서 실행
const _ = require("lodash");
// 깊은 복사
const c2 = _.cloneDeep(o);
console.log(c2 === o); // false
console.log(c2.x === o.x); // false
```

2. 참조에 의한 전달

- 객체 변수를 할당하면 원본의 참조 값이 복사되어 전달 -> 참조에 의한 전달
- 여러 개의 객체가 하나의 객체 공유 가능 -> 프로퍼티 변경 시 서로 영향을 받음

---

## 12장 함수

- 일련의 과정을 문으로 구현하고 코드 블록으로 감싸 하나의 실행 단위로 정의한 것
- 코드의 재사용 및 중복 제거
- 코드의 신뢰성: 유지보수의 편의성
- 적절한 이름으로 코드의 가독성 향상

### 12-3. 함수 리터럴

- 함수는 객체 타입의 값

  - JS의 특징
  - 함수 리터럴로 생성 가능
  - 일반 객체와 달리 호출할 수 있고, 고유한 프로퍼티를 가짐

- 함수 이름: 함수 몸체 내에서만 참조할 수 있는 식별자

### 12-4. 함수 정의

1. 함수 선언문

```js
// 함수 선언문
function add(x, y) {
  return x + y;
}

// 함수 참조
// console.dir은 console.log와는 달리 함수 객체의 프로퍼티까지 출력한다.
// 단, Node.js 환경에서는 console.log와 같은 결과가 출력된다.
console.dir(add); // ƒ add(x, y)

// 함수 호출
console.log(add(2, 5)); // 7
```

- 함수 리터럴과 형태 동일하나 이름 생략 불가
- 표현식이 아닌 문 -> 완료 값 undefined

```js
// 함수 선언문은 표현식이 아닌 문이므로 변수에 할당할 수 없다.
// 하지만 함수 선언문이 변수에 할당되는 것처럼 보인다.
var add = function add(x, y) {
  return x + y;
};

// 함수 호출
console.log(add(2, 5)); // 7
```

- 함수 선언문이 변수에 할당되는 것처럼 동작하는 이유
  - JS 엔진이 문맥에 따라 표현식이 아닌 문인 함수 선언문 or 표현식인 함수 리터럴로 해석하는 경우가 있기 때문임.
  - 함수 리터럴 단독 사용 시 선언문으로, 함수 리터럴을 변수에 할당하거나 피연산자로 사용하면 함수 리터럴 표현식으로 해석함.
- JS 엔진은 생성된 함수를 호출하기 위해 함수 이름과 동일한 식별자를 암묵적으로 생성하고, 거기에 함수 객체를 할당한다.
  - **함수 호출 시 함수 객체를 가리키는 식별자로 호출**함

2. 함수 표현식

- 일급 객체: 값의 성질을 갖는 객체
  - 함수는 값처럼 변수에 할당할 수 있고, 프로퍼티 값 or 배열 요소가 될 수 있음
- 함수 표현식: 함수 리터럴로 생성한 함수 객체를 변수에 할당하는 방식
- 보통 함수 이름을 생략함 (익명 함수)

```js
// 기명 함수 표현식
var add = function foo(x, y) {
  return x + y;
};

// 함수 객체를 가리키는 식별자로 호출
console.log(add(2, 5)); // 7

// 함수 이름으로 호출하면 ReferenceError가 발생한다.
// 함수 이름은 함수 몸체 내부에서만 유효한 식별자다.
console.log(foo(2, 5)); // ReferenceError: foo is not defined
```

- 함수 선언문: 표현식이 아닌 문
- 함수 표현식: 표현식인 문 -> 정확히 동작하지 않는다.

3. 함수 생성 시점과 함수 호이스팅

```js
// 함수 참조
console.dir(add); // ƒ add(x, y)
console.dir(sub); // undefined

// 함수 호출
console.log(add(2, 5)); // 7
console.log(sub(2, 5)); // TypeError: sub is not a function

// 함수 선언문
function add(x, y) {
  return x + y;
}

// 함수 표현식
var sub = function (x, y) {
  return x - y;
};
```

- 함수 선언문 함수와 함수 표현식 함수는 생성 시점이 다름
  1. 함수 선언문: 선언문 이전에 호출 가능: 런타임 이전에 함수 객체로 초기화 -> 함수 호이스팅
  2. 함수 표현식: 표현식 이전에 호출 불가: 런타임 이전에 undefined로 초기화 -> 변수 호이스팅

5. 화살표 함수

- `function` 대신 화살표로 정의 -> 항상 익명 함수
- 기존 함수와 비교하여 표현, 내부 동작 간략화
  - 생성자로 사용 불가, `this` 바인딩 방식 차이, `prototype` 부재, `arguments` 객체 생성 X

### 12-5. 함수 호출

1. 매개변수와 인수

- 함수 내에서 일반 변수처럼 `undefined`로 초기화되고 인수가 순서대로 할당 됨
- (초과된 인수 포함) 인수는 암묵적으로 `arguments` 객체의 프로퍼티로 보관 됨

```js
function add(x, y) {
  console.log(arguments);
  // Arguments(3) [2, 5, 10, callee: ƒ, Symbol(Symbol.iterator): ƒ]

  return x + y;
}

add(2, 5, 10);
```

2. 인수 확인

- JS는 동적 타입 언어 -> 매개변수 타입 사전 지정 불가
- 런타임에 에러를 발생시킴 -> TS는 정적 타입 언어로 컴파일 시점에 먼저 에러를 감지하게 함
- ES6부터 매개변수 기본값 사용

3. 매개변수의 최대 개수

- 매개변수는 적을수록 좋으며 많을 경우 객체로 전달하는 것을 권장
  - 단, 내부로 전달한 객체를 내부에서 변경하면 외부의 객체가 변경되는 부수효과를 주의해야 함.

4. 반환문

- 반환 값이 없으면 암묵적으로 `undefined` 반환

### 12-6. 참조에 의한 전달과 외부 상태의 변경

매개 변수도 값에 의한 전달, 참조에 의한 전달을 그대로 따른다.

```js
// 매개변수 primitive는 원시값을 전달받고, 매개변수 obj는 객체를 전달받는다.
function changeVal(primitive, obj) {
  primitive += 100;
  obj.name = "Kim";
}

// 외부 상태
var num = 100;
var person = { name: "Lee" };

console.log(num); // 100
console.log(person); // {name: "Lee"}

// 원시값은 값 자체가 복사되어 전달되고 객체는 참조값이 복사되어 전달된다.
changeVal(num, person);

// 원시값은 원본이 훼손되지 않는다.
console.log(num); // 100

// 객체는 원본이 훼손된다.
console.log(person); // {name: "Kim"}
```

- 객체 전달 시 부수효과를 방어하기 위해서
  1. 옵저버 패턴 사용: 객체 참조하는 이들에게 변화를 공유
  2. 불변객체로 사용하기: 깊은 복사(방어적 복사)로 새로운 객처를 생성하고 재할당을 통해 교체

### 12-7. 다양한 함수의 형태

1. 즉시 실행 함수

- 정의와 동시에 호출되는 함수. 다시 실행할 수 없다
- 값 반환 및 인수 전달 가능

```js
// 즉시 실행 함수도 일반 함수처럼 값을 반환할 수 있다.
var res = (function () {
  var a = 3;
  var b = 5;
  return a * b;
})();

console.log(res); // 15

// 즉시 실행 함수에도 일반 함수처럼 인수를 전달할 수 있다.
res = (function (a, b) {
  return a * b;
})(3, 5);

console.log(res); // 15
```

2. 재귀 함수

- 재귀 -> 자기 자신을 호출하는 함수 -> 반복을 위해 사용
- 함수 이름은 내부에서만 유효하므로 이름으로 호출하여 반복문 피할 수 있음
  - 식별자로도 호출 가능
- 직관적인 재귀 함수 표현이 필요할 때 사용하는 것이 좋음

```js
// 함수 표현식
var factorial = function foo(n) {
  // 탈출 조건: n이 1 이하일 때 재귀 호출을 멈춘다.
  if (n <= 1) return 1;
  // 함수를 가리키는 식별자로 자기 자신을 재귀 호출
  return n * factorial(n - 1);

  // 함수 이름으로 자기 자신을 재귀 호출할 수도 있다.
  // console.log(factorial === foo); // true
  // return n * foo(n - 1);
};

console.log(factorial(5)); // 5! = 5 * 4 * 3 * 2 * 1 = 120
```

4. 콜백 함수

- 콜백 함수: 매개 변수를 통해 다른 함수 내부에 전달되는 함수
- 고차 함수: 매개 변수를 통해 함수의 외부에서 콜백 함수로 전달받은 함수

```js
// logOdds 함수는 단 한 번만 생성된다.
var logOdds = function (i) {
  if (i % 2) console.log(i);
};

// 고차 함수에 함수 참조를 전달한다.
repeat(5, logOdds); // 1 3
```

- 고차 함수가 자주 호출된다면 콜백 함수가 그 때마다 함수 객체를 생성하므로, 외부에서 정의 후 전달하는 게 효율적임
- 배열 고차 함수 ex) map, filter, reduce ...

5. 순수 함수와 비순수 함수

- 순수 함수: 부수 효과가 없고 외부 상태에 의존하지 않음
  - 함수 내부 상태에만 의존해도 내부 상태가 호출될 때마다 변화하는 값(시간)이 있다면 순수 함수가 아님.
- 비순수 함수: 부수 효과가 있고 외부 상태에 의존함

  - 외부 상태 직접 참조하지 않아도 객체 전달 받으면 비순수 함수가 됨.

- 함수형 프로그래밍: 순수 함수 + 보조 함수 조합을 통해 부수 효과를 최소화해서 불변성을 지향하는 프로그래밍 기법 -> 최대한의 순수 함수

---

## 13장 스코프

### 13-1. 스코프란?

- 식별자가 유효한 범위 -> 자신이 선언된 위치에 따라 유효 범위가 달라진다
- 네임스페이스
- 식별자 결정: 중복 변수가 있다면 어떤 변수를 참조해야 할 지 결정하는 것
  - 스코프는 식별자 검색할 때 사용하는 규칙

```js
function foo() {
  var x = 1;
  // var 키워드로 선언된 변수는 같은 스코프 내에서 중복 선언을 허용한다.
  // 아래 변수 선언문은 자바스크립트 엔진에 의해 var 키워드가 없는 것처럼 동작한다.
  var x = 2;
  console.log(x); // 2
}
foo();
```

- var 키워드로 선언한 변수는 같은 스코프 내에서 중복 선언이 허용된다.

### 13-3. 스코프 체인

- 스코프 체인: 스코프가 계층적으로 연결된 것
- JS 엔진은 스코프 체인을 통해 변수를 참조하는 스코프에서 시작하여 상위 스코프 방향으로 이동하며 선언된 변수를 검색한다.
- 하위 -> 상위 스코프 참조는 자유로우나 상위 -> 하위 스코프 참조는 제한적이다.

### 13-4. 함수 레벨 스코프

- var 키워드는 코드 블록이 아닌(블록 레벨 스코프) 함수에 의해서만 지역 스코프가 생성된다. (함수 레벨 스코프)
- let, const는 블록 레벨 스코프를 지원함

---
