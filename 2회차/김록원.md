# 10장 - 객체 리터럴
js는 원시 값을 제외한 나머지 값(함수, 배열, 정규표현식 등)은 모두 객체이다.  
js는 **프로토타입 기반 객체지향 언어**로 클래스 기반 객체지향 언어와는 달리 다양한 객체 생성 방법을 지원한다.  
<br />  

**객체 생성 방법**
- 객체 리터럴
- Object 생성자 함수
- 생성자 함수
- Object.create 메서드
- 클래스(ES6)  

**객체 리터럴의 특징**  
- 객체 리터럴은 js의 유연함과 강력함을 대표하는 객체 생성 방식.(객체를 생성과 동시에 프로퍼티 만들기, 생성 이후에도 프로퍼티를 동적으로 추가 가능)  
- 객체 리터럴을 제외한 다른 객체 생성방식은 모두 함수를 사용함.  
```js
var person = {
  name: 'Lee',
  sayHeelo: function() {
    console.log('Hello! My name is ${}' )
  }
}
```  
<br />

### 객체리터럴의 프로퍼티의 특징
1. 프로퍼티 키로 모든 문자열 또는 심벌값을 사용할 수 있다.
2. 프로퍼티 키로 식별자 네이밍 규칙을 지킨다면 따옴표를 사용하지 않고 작성 가능하다.
3. 문자열로 평가할 수 있는 표현식을 사용해 프로퍼티 키를 동적으로 생성할 수 있다.(대괄호 이용)
4. 프로퍼티 키로 문자열 혹은 심벌값 이외의 값을 사용하면 암묵적으로 타입 변환을 통해 문자열이 된다.
5. 프로퍼티 키를 중복선언 시 나중에 선언한 프로퍼티가 덮어쓴다.
6. 프로퍼티 값으로 함수(메서드)를 사용할 수 있다. js에서 함수는 (일급)객체이므로 값으로 취급한다.
```js
var person = {
  lastName: 'Kim', // 2
  1: 3, // 4
  lastName: 'Lee',  // 5
  say: function () { // 6
    console.log(this.lastName);
    console.log(this['1'], this[1]);
    console.log(this.age);
  }
};

person['age'] = 21; // 3
person.say();
```  
<br />


### 객체리터럴의 프로퍼티 접근
프로퍼티에 접근하기 위한 방법으로 마침표 표기법과 대괄호 표기법이 존재한다.  

1. 프로퍼티 키가 식별자 네이밍 규칙을 준수한다면 마침표 표기법을 이용해 접근가능하다.
2. 대괄호 표기법을 이용해 접근할때는 반드시 따옴표로 감싼 문자열이어야 한다.
3. delete 연산자를 이용해 객체의 프로퍼티를 삭제할 수 있다.  
```js
var person = {
  age: 37
};
console.log(person.age);
console.log(person[age]) // Reference error
console.log(person['age']);
console.log(person.name) // undefined

delete person['age'];
console.log(person.age) // undefined
```  
<br />


### ES6부터 추가된 내용
1. 프로퍼티 축약 표현(값으로 사용되는 변수 이름과 프로퍼티 키 이름이 같다면 프로퍼티 키 생략 가능)
2. Computed Property Name(프로퍼티 키를 동적으로 생성가능)
3. 메서드 축약표현 (function 키워드를 생략한 축약 표현을 사용가능)
```js
let x = 1, y = 2;

const obj = {
  x, y,
  [`${x} + ${y}`]: x + y,
  say() {
    console.log(obj) // { x: 1, y: 2, '1 + 2': 3, say: [Function: say] }
  }
};
obj.say();
```  
<br />

### 🤔 템플릿 리터럴이 객체리터럴의 프로퍼티 키가 될 수 없는 이유
[템플릿 리터럴이 객체리터럴의 프로퍼티 키가 될 수 없는 이유](https://stackoverflow.com/questions/33194138/template-string-as-object-property-name)  
템플릿 리터럴이 표현식(값으로 판단)이기 때문! 문자열 리터럴이 아님! 단지 런타임에서 문자열로 변환해주는 것 뿐

<br />
<hr />
<br />

# 11장 - 원시 값과 객체의 비교
원시 타입과 객체 타입의 차이 3가지  
- 원시값은 불변의 값이며, 객체는 변경 가능한 값이다.  
- 원시값을 변수에 할당 시 실제 값이 저장, 객체를 변수에 할당 시 참조 값이 저장된다.
- 원시값을 다른 변수에 할당하면 원시값이 복사되어 전달, 객체는 원본의 참조값이 복사되어 전달  
<br />

### 원시깂의 특징  
원시값은 변경불가능하다. 만약 변수에 할당 및 재할당을 할 경우 값이 바뀌는 것이 아니라 새로운 공간을 확보 후 할당된 값을 저장, 변수는 새롭게 재할당한 윈시 값을 가리킴.  
즉 변수가 가리키는 메모리 공간이 바뀌며 값은 변하지 않는다. 값의 이러한 특성을 **불변성**이라고 한다.  
<br />

### js의 문자열  
js에서 문자열은 객체가 아닌 원시값이다.  
하지만 유사배열객체로써 인덱스 접근, length 프로퍼티를 가지고 있다.  
다만, 원시값이기때문에 문자열 중 일부 문자열을 변경하는 것은 불가능하다.
```js
var str = 'string';
str[0] = 'S';
console.log(str); // string
```  
<br />

### 다른 언어와 비교하는 값에 의한 전달  
python의 경우 처음 변수에 원시 값을 갖는 변수를 할당하는 시점에는 두 변수가 같은 메모리 공간을 가리키고 있다. 두 변수 중 하나에 값을 재할당했을때 비로소 서로 다른 메모리 공간을 갖는다.  
<br />  

### 객체  
프로퍼티의 정해져있지 않으며, 동적으로 추가/삭제 가능하다. 프로퍼티 값에 대한 제약도 없다.  
원시 값과 같이 확보해야 할 메모리 공간의 크기를 사전에 정해 둘 수 없다.  
따라서 원시 값과는 다른 방식으로 동작하도록 설계되어있다.  
<br />

### js 객체의 관리방식  
해시 테이블이라고 생각할 수 있지만 대부분의 엔진은 성능을 위해 더 나은 방법으로 객체를 구현한다.  
js의 객체는 매우 편리하지만(동적 추가/삭제) 성능 면에서는 접근에 비용이 많이든다.  
v8엔진은 동적 탐색 대신 히든 클래스라는 방식을 사용해(C++ 객체의 프로퍼티에 접근하는 정도의 성능을 보장한다.)  
<br />

### 객체 - 변경가능한 값
객체를 변경할 때마다 원시 값처럼 이전 값을 복사해 새롭게 생성한다면 비용이 많이 들 것이다.(객체의 크기가 매우클수도 있으며 크기도 일정하지 않으므로)  
즉, 메모리의 효율적 소비가 어렵고 성능이 나빠진다.  
객체를 복사해 생성하는 비용을 절약하여 성능을 향상시키기 위해 변경 가능한 값으로 설계되었다. 이에 따른 부작용으로 여러 개의 식별자가 하나의 객체를 공유할 수 있다.

객체 생성 시 변수의 메모리 공간에는 객체가 존재하는 메모리 공간에 대한 참조값이 저장된다.  
따라서 다른 변수에 할당시 이 참조값이 해당 변수의 메모리 공간에 들어가게 된다.  
객체의 프로퍼티에 접근 시 해당 참조값을 통해 접근하게 되므로 같은 객체의 프로퍼티를 접근하게 된다.  
<br />

### 🤔 히든 클래스의 객체 관리 방식
정적 언어의 경우 각 프로피터마다 offset을 가진다. 프로퍼티를 참조할 경우 offset을 이용하기 때문에 O(1)의 시간복잡도를 갖는다.  
js는 동적으로 프로퍼티를 추가/삭제를 할 수 있으므로 애초부터 offset을 가지고 있기 힘들다. 이를 가능하게 하기 위해 Hidden Class + Inline Caching을 이용한다.  
https://ui.toast.com/weekly-pick/ko_20210909  
https://meetup.toast.com/posts/78  
이것도 결국엔 오버헤드가 존재하기 때문에 정적인 언어라고 생각하고 사용하는 것이 성능상 이점이 많다.  
<br />

### 🤔 히든 클래스 생성에 따른 메모리 오버헤드?  

<br />
<hr />
<br />

# 12장 - 함수
js에서 함수는 객체 타입의 값이다. 그러므로 함수 또한 함수 리터럴로 생성할 수 있다.  
js에서 함수를 정의하는 방법은 다음과 같다.
- 함수 선언문
- 함수 표현식
- Function 생성자 함수
- 화살표 함수(ES6)  
<br />

### 함수 선언문
- 함수 리터럴은 이름을 생략할 수 있으나 함수 선언문은 생략할 수 없다.
- 함수 선언문은 문이지만 표현식은 아니다.  
- 런타임 전 함수 호이스팅으로 선언과 동시에 함수 객체를 생성한다.
- js엔진이 암묵적으로 함수 이름을 식별자로 생성한다.
```js
function add(x, y) {
  return x + y;
}

console.log(add(2,5));
```  
<br />  

### 함수 표현식  
- js의 함수는 값처럼 변수에 할당, 프로퍼티의 값, 배열의 요소가 될 수 있다.(일급 객체)
- 리터럴의 함수 이름은 생략할 수 있다.(익명 함수)
- 표현식은 함수 호이스팅이 아닌 변수 호이스팅의 영향을 받기 때문에 함수 객채가 런타임 전에 생성되지는 않는다.
```js
var sub = function (x, y) {
  return x - y;
}
```  
<br />  

### Function 생성자 함수
- Function 생성자 함수에 매개변수 목록과 함수 몸체를 문자열로 전달하여 생성한다.
- 클로저를 생성하지 않는 듯 선언문, 표현식으로 생성한 함수와 다르게 동작한다.
```js
var add = new Function('x', 'y', 'return x + y');
console.log(add(2, 5));
```  
<br />

### 화살표 함수  
- function 키워드 대신에 `=>`를 사용해 간략한 방법으로 함수를 선언할 수 있으며 항상 익명 함수로 정의한다.
- 표현만 간략한 것이 아니라 내부 동작또한 간략화 되어 있다.(생성자 함수로 사용X, this 바인딩, prototype 프로퍼티가 없으며 Argument 객체를 생성하지 않음)  
```js
const add = (x,y) => x + y;
```  
<br />


### js 함수의 특징
- js 엔진은 문맥에따라 함수 선언문인지 함수 리터럴인지를 판단한다.  
- 인수가 매개변수의 수를 초과하면 초과된 인수들은 무시된다(argument 객체에 보관함)  
- 인수가 매개변수 보다 적으면 나머지 값들은 undefined 값이다.  
<br />  

### IIFE(Immediately Invoked Function Expression)  
- 즉시실행 함수는 단 한 번만 호출되며 다시 호출 할 수 없다.
- 즉시실행 함수는 정의되자마자 실행된다.  
- 그룹 연산자 `( )`를 이용해 감싸야 한다.
```js
(function fool() { })();
```  
<br />  


### 고차함수와 콜백함수  
함수의 매개변수를 통해 다른 함수의 내부로 전달되는 함수를 콜백함수라고 부르며  
외부에서 콜백함수를 전달받은 함수를 고차 함수라고 부른다.  
고차 함수는 콜백 함수를 자신의 일부분으로 합성한다.  
<br />

### 순수 함수와 비순수 함수
순수 함수는 어떤 외부 상태에 의존하지 않고 변경하지도 않는 부수 효과가 없는 함수다. 동일한 인수가 전달되면 언제나 동일한 값을 반환하는 함수이다.(외부 상태뿐만이 아닌 호출될때마다 변하는 값(현재 시간 등)에 의존하지 않는다.) 순수 함수의 목적은 부수효과를 최소화에 불변성을 지향하는 것이다.  

<br />
<hr />
<br />  

# 13장 - 스코프  
모든 식별자는 자신이 선언된 위치에 의해 다른 코드가 식별자 자신을 참조할 수 있는 유효 범위가 결정된다. 즉, 스코프는 식별자가 유효한 범위를 말한다.  
'코드가 어디서 실행되며 주변에 어떤 코드가 있는지'를 **렉시컬 환경** 이라고 부른다.  
코드의 문맥은 렉시컬 환경으로 이뤄진다.  
이러한 코드의 문맥을 구현한 것이 `실행 컨텍스트`이다. 코든 코드들은 실행 컨텍스트에서 평가되고 실행된다.  

### 스코프의 종류  
변수는 자신이 선언된 위치에 의해 유효 범위인 스코프가 결정된다. 크게 전역과 지역 스코프가 존재한다. 여기서 지역이란 함수 몸체 내부를 뜻한다. 전역변수는 어디서든 참조가 가능하며 지역 변수는 지역 내에서만 참조가 가능하다.  
<br />  

### 스코프 체인  
js엔진은 스코프 체인을 통해 변수를 참조하는 코드의 스코프부터 시작해 상위 스코프 방향으로 선언된 변수를 검색한다. 가장 상위는 전역스코프이며 전역 스코프부터 힘수, 중첩함수순으로 체이닝되어 있다.  
전역 변수는 최상위이기에 검색시 가장 늦게 확인하므로 검색속도가 느리다.  
(+ 호이스팅은 스코프 단위로 동작한다.)  
<br />  

### 레시컬 스코프
```js
var x = 1;

function foo() {
  var x = 10;
  bar();
}

function bar() {
  console.log(x);
}

foo(); // 1
bar(); // 1
```
bar 함수의 상위 스코프가 무엇인지에 따라 결과값이 결정된다.  
- `동적 스코프` : 함수를 어디서 호출했는지에 따라 상위 스코프 결정
- `렉시컬/정적 스코프` : 함수를 어디에 정의했는지에 따라 상위 스코프 결정  
대부분의 언어는 렉시컬 스코프를 지원하며 js또한 마찬가지이다.  

<br />
<hr />
<br />  

# 14장 - 전역 변수의 문제점  
지역변수의 경우 함수가 호출되어 실행되는 동안에만 유효하다. 즉 지역변수의 생명주기는 함수의 생명 주기와 일치한다. 전역변수는 전역객체의 프로퍼티가 된다. 즉 생명주기는 전역 객체의 생명 주기와 일치한다.  
- 모든 코드에서 참조하고 변경할 수 있기에 의도치 않은 상태 변경에 쉽게 노출된다.
- 전역객체와 생명주기(프로그램이 동작 종류까지)가 같으므로 오랜 시간 메로리를 차지한다.  
- 스코프 체인상 가장 최상단이므로 검색속도가 느리다.  
- 파일 내에서 동일한 이름으로 존재하는 변수가 있을 시 예상치 못한 결과를 가져올 수 있다.  

전역변수 사용 억제하기  
- 즉시 실행 함수를 사용하고 내부에 변수를 이용하기  
- 모듈 패턴 이용하기
- ES6 모듈(독자적인 모듈 스코프를 제공하기 때문에 모듈 내에 선언해도 전역변수로 선언되지 않는다.)  

<br />
<hr />
<br />  

# 15장 - let, const 키워드와 블록 레벨 스코프  
`var`의 문제점  
- 변수 중복 선언을 허용한다(이미 선언된 것을 모른다면 부작용 발생)  
- 함수 레벨 스코프(if나 for문에서는 같은 스코프로 동작함)
- 변수 호이스팅(할당 이전에 값을 불러와 undefined로 연산될 가능성이 높음)  

`let`으로 단점 보완  
- 변수 중복 선언을 금지!
- 블록 레벨 스코프로 if, for문에서의 변수도 다른 스코프로 취급
- 변수 호이스팅에 대해 var보다 비교적 안정적(초기화 시작 전까지 변수를 참조할 수 없는 구간존재 - TMZ)  
- let으로 선언하면 전역객체의 프로퍼티가 아님 개념적인 블록 내에 존재함  

`const`란  
- 코드로는 선언과 동시에 초기화를 해줘야함
- 재할당 금지!(객체는 메모릐 공간의 주소값을 아예 바꾸지 않은 이상 객체 내 프로퍼티 변경은 가능)  

어떻게 사용할까?  
- ES6를 사용한다면 var 키워드 사용하지 않기
- 재할당이 필요한 경우에 한정해 let사용, 변수의 스코프는 최대한 좁게
- 변경이 발생하지 않고 읽기 전용으로 사용하는 경우 const사용하기