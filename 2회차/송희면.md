# 내용 정리

## 10장 - 객체 리터럴
### 객체란?  
원시 값을 제외한 나머지 값이다. (`함수, 배열, 정규 표현식` 등)  
타양한 타입의 값을 하나의 단위로 구성한 `복합 자료구조`이다.  
`변경 가능한 값 (mutable value)`

<br>

### 객체의 구성 요소
객체는 프로퍼티의 집합이고, 프로퍼티는 키와 값으로 구성됨.  
* `프로퍼티` : 객체의 `상태`를 나타내는 값
* `메서드` : 프로퍼티를 참조하고 조작하는 `동작`
  * (함수는 일급 객체이므로 값으로 취급이 가능하여 프로퍼티 값으로 사용 가능.)

<br>

### 객체 생성
1. 객체 리터럴 `가장 일반적`
2. Object 생성자 함수
3. 생성자 함수
4. Object.create 메서드
5. 클래스(ES6)

<br>

### 프로퍼티 접근 방법
1. 마침표 표기법
2. 대괄호 표기법
   1. 계산된 프로퍼티 이름을 사용하려면 대괄호 표기법을 사용한다.  
      : 문자열 또는 문자열로 타입 변환할 수 있는 값으로 평가되는 표현식을 사용하여 프로퍼티 키를 동적으로 생성할 수 있다. 



<br>
<br>
<br>

---

## 11장 - 원시 값과 객체의 비교
### 1. 원시 값
변경 불가능한 값.  
확보한 메모리 공간에 실제 값을 저장.  

### 2. 불변성
변경 불가능한 값은 직접 변경할 수 없다.  
> 원시값은 불변성을 갖는다.
 
> 변경 불가능한 값의 뜻 : 변수가 아닌 값에 대한 설명임.  
> 재할당 이외에 변수 값을 변경할 수 있는 방법은 없다.  

### 3. 문자열은 불변값
문자열은 원시값이지만 객체처럼 사용한다면 자동 변환되어 객체처럼 쓸 수 있다.
```js
var string = 'Bye World';
string = 'Hello World'; 
// 새로운 문자열 'Hello World'를 메모리에 생성하고, 식별자 string은 이것을 가리킨다.

// 유사 배열이므로 인덱스를 활용하여 각 문자에 접근 가능하다.
string[2]; // l
string.length; // 11
string.toUpperCase(); // HELLO WORLD 

string[2] = 'L';
console.log(string); // Hello World
// 하지만 원시값이기에 값을 변경할 순 없다.
```

### 4. 객체
참조 타입의 값으로 변경 가능하다.  
객체는 프로퍼티의 개수가 정해져 있지 않고, 동적으로 추가/삭제 할 수 있다.

1. `변경 가능한 값`
    * 객체는 참조 타입의 값이다.   
      ```js
      // 할당이 이루어지는 시점에 객체 리터럴이 해석되고 그 결과 객체가 생성된다.  
      // 변수에 담기는 값은 객체의 참조값이다.
      var person = {
        name: 'song'
      };
      // 변수 person은 객체 {...}를 가리키고(참조하고) 있다.
      ```
      원시 값을 갖는 변수는 `재할당`을 통해 변경.  
      객체는 직접 수정할 수 있다.
      ```js
      // 프로퍼티 값 갱신
      person.name = 'kim';

      // 프로퍼티 동적 생성
      person.address = 'Gyung-gi';

      consoel.log(person); // {name: 'kim', address: 'Gyung-gi'}
      ```
2. `깊은 복사` VS `얕은 복사`  
`원시 값`을 복사하면 `깊은 복사`.  
`참조 값`을 복사하면 `얕은 복사`.  
<br>
`spread` 연산자는 1 depth까지만 복사하며, 중첩된 객체는 복사하지 못 한다.

3. 참조에 의한 전달 `얕은 복사`
     ```js
      var person = {
        name: 'song'
      };

      // 참조 값을 복사(얕은 복사) 했다. 
      // 변수 person과 변수 copy는 저장된 메모리 주소가 다른 서로 다른 변수이지만,  
      // 동일한 참조 값을 가리킨다.
      var copy = person; // 즉, 두 개의 식별자가 하나의 객체를 공유.
      ```
<br>
<br>
<br>

---

## 12장 - 함수
### 1. 함수?
`입력(parameter)`을 받아 `출력(return)`을 하며, 일련의 과정을 문으로 구현하고 `코드 블록`으로 감싸서 `하나의 실행 단위로 정의`한다.

```js
// 함수의 정의
function 함수이름(매개변수1, 매개변수2) {
  // 함수의 몸체
  // 일련의 과정들...

  // 반환
  return 반환값;
}

// 함수 호출
함수이름(인수1, 인수2); 
```
함수를 정의하고 `호출`을 해야 실행된다. 

<br>

### 2. 함수를 사용하는 이유
1. 코드의 재사용
2. 유지보수의 편의성을 높임.
3. 코드의 신뢰성과 가독성 향상

<br>

### 3. 함수 정의
함수는 `일급 객체`이다. 

1. 함수 선언문
    ```js
    // 선언문은 함수 이름을 생략할 수 없다. undefined를 반환한다.
    function add(a, b) {
      return a + b;
    }
    ```
2. 함수 표현식
    ```js
    // 리터럴은 값으로 평가되어 변수에 할당할 수 있다.
    var add = function (a, b) {
      return a + b;
    }
    ```
3. Function 생성자 함수
    ```js
    var add = new function ('a', 'b', ' return a + b');
    ```
4. 화살표 함수
    ```js
    var add = () => {
      // ...
    }
    ```

### 4. 함수 생성 시점과 함수 호이스팅
1. `함수 선언문`   
    호이스팅 된다.   
    암묵적으로 식별자가 생성되고 함수 객체로 초기화된다.  
    ```js
    // 1. 참조 가능
    console.dir(add); // f add(a,y)

    // 2. 호출 가능
    add(2, 5); 

    // 3. 함수 선언문
    function add(a, b) {
      // ...
    }
    ```

2. `함수 표현식`  
    함수 호이스팅이 아닌 `변수 호이스팅`이 된다.  
    ```js
    // 1. var 키워드로 선언했기에 변수는 undefined로 초기화된다.
    console.dir(sub); // undefined

    // 2. TypeError: sub is not a function
    sub(2, 5);

    var sub = function (a, b) {
      // ...
    }
    ```

<br> 

3. Function 생성자 함수   
    클로저를 생성하지 않는다. 선언문이나 표현식과는 다르게 동작한다.
    ```js
    var test = (function() {
      var a = 10;
      return function (x, y) {
        return x + y + a;
      };
    }());

    console.log(test(1, 2)); // 13
    ```
    > 클로저를 생성하지 않는 Function 생성자 함수
    ```js
    var test2 = (function() {
      var a = 10;
      return new Function ('x', 'y','return x + y + a');
    }());

    console.log(test2(1, 2)); // ReferenceError: test2 is not defined.
    ```

4. 화살표 함수  
    `this` 바인딩 방식이 다르다.  
    `생성자 함수`로 사용할 수 `없다`.  
    `prototype 프로퍼티`가 없다. `arguments 객체`를 생성하지 않는다.  

<br> 

### 5. 함수 호출
인수가 할당되지 않은 매개변수의 값은 `undefined`  
초과된 인수는 버려지지 않는다. 모든 인수는 `arguments 객체`의 `프로퍼티`로 보관된다.  

```js
function test(a, b) {
    console.log(a, b, arguments)
}
test(1,2,3,4);

// 1 2
// > Arguments(4) [1, 2, 3, 4, callee: ƒ, Symbol(Symbol.iterator): ƒ]
// >> 0: 1
// >> 1: 2
// >> 2: 3
// >> 3: 4
```

<br> 


### 6. 참조에 의한 전달과 외부 상태의 변경
`원시 타입 인수`는 값 자체가 복사되어 매개변수로 전달되므로 함수 몸체에서 그 값을 변경해도 원본은 훼손되지 않는다.  

`객체 타입 인수`는 참조 값이 복사되어 매개변수로 전달된다. 함수 몸체에서 참조 값을 통해 객체를 변경할 경우 원본이 훼손된다.  
이 때문에 객체를 불변객체로 만들어 사용한다. (깊은 복사)

<br> 

### 7. 다양한 함수의 형태
1. IIFE
   ```js
   (function() {}());
   // 그룹 연산자로 묶은 이유는 리터럴로 평가하여 함수 객체를 생성하기 위함이다. 
   ```


2. 재귀 함수  
    반복 처리를 하기 위함이다. 스스로를 호출하는 행위.  

3. 중첩 함수  
    함수 내부에 정의 된 헬퍼 함수.  

4. 콜백함수  
  함수의 매개변수를 통해 다른 함수의 내부로 전달되는 함수.  
    > 사용처
    > 1. 비동기 처리: 이벤트함수, ajax통신, 타이머함수 등  
    > 2. 배열의 고차 함수 
    >> 콜백 함수를 전달받은 함수는 고차 함수라 한다. (HOF)

5. 순수 함수와 비순수 함수
`순수 함수`: 어떤 외부 상태에 의존하지 않고 변경하지 않는 함수.

### 6. `객체를 인수`로 사용하는 경우
프로퍼티 키만 정확히 지정하면 매개변수의 순서는 신경쓰지 않아도 된다.   
> 그러나 함수 외부에서 함수 내부로 전달한 객체를 함수 내부에서 변경하면 함수 외부의 객체가 변경되는 side effect가 발생한다.  

### 7. `return`
반환문의 역할을 두 가지이다.
1. 함수 실행을 중단하고 몸체를 빠져나간다.
2. return 키워드 뒤에 오는 표현식을 평가하여 반환한다.   
    `(명시하지 않으면 undefined가 반환.)`

<br>
<br>
<br>

---
## 13장 - 스코프
### 1. 스코프?
`JS 엔진이 식별자를 검색할 때 사용하는 규칙` 으로 `식별자가 유효한 범위` 이다.

> 식별자 : 변수 이름, 함수 이름, 클래스 이름 등

<br>

### 2. 선언된 위치에 의해 스코프가 결정된다.
`선언된 위치`에 의해 자신이 유효한 범위가 결정된다.  
즉 다른 코드가 변수 자신을 참조할 수 있는 범위가 결정된다.

<br>

### 3. 스코프가 다른 같은 이름의 변수 x
```js
var x = 'g'; // 전역 스코프의 변수 x

function foo() {
  var x = 'l'; // foo 함수 스코프의 변수 x
  console.log(x); // 'l'
}

foo();
console.log(x); // 'g'
```
스코프는 코드의 **`문맥(context)`** 을 고려하여 같은 이름의 변수 중 어떤 변수를 참조할 것인지 결정하는 규칙이다. 위와 같이 스코프가 다르다면 변수의 이름은 중복될 수 있다.

> 코드의 문맥은 렉시컬 환경으로 이루어짐.  
> 1. 렉시컬 환경: 코드가 어디서 실행되며 주변에 어떤 코드가 있는지.
> 2. 실행 컨텍스트: 렉시컬 환경을 구현한 것. 모든 코드가 실행 컨텍스트에서 평가되고 실행된다.  


<br>

### 4. `var` VS `let`, `const`
`var`는 같은 스코프 내에서 중복 선언을 허용한다.

`let`, `const`는 같은 스코프 내에서 중복 선언을 허용하지 않는다.

```js
SyntaxError: Identifier 'a' has already been declared.

  25 |
  26 | let a = 1;
> 27 | let a = 2;
```

<br>

### 5. 전역과 지역
`전역`: 코드의 가장 바깥 영역으로 전역 변수는 어디서든지 참조 가능하다.  

`지역`: 함수 몸체 내부를 말한다.  
`지역 변수`: 지역에 선언된 변수. 자기 자신의 지역 스코프와 하위 지역 스코프에서 유효하다.

<br>

### 6. 스코프 체인
함수는 중첩될 수 있고, 이런 특징으로 스코프도 중첩되어 `계층적 구조`를 갖는다.  
중첩 함수의 상위 스코프는 본인을 포함하는 외부 함수가 된다.

> 함수를 정의할 수 있는 곳 
> - 전역
> - 함수 몸체 내부 : 내부에서 정의된 함수를 `중첩 함수`라 하고, 중첩 함수를 포함하는 함수를 `외부함수`라 한다.

최상위 스코프는 전역 스코프이다.

<br>

### 7. 함수 레벨 스코프
`함수 레벨 스코프` : 코드 블록이 아닌 `함수에 의해서만 지역 스코프가 생성`된다.

`블록 레벨 스코프` : if, for, while, try/catch 등..

<br>

### `var`는 함수 레벨 스코프이다. 

```js
// 예시1)

var x = 'g';

if (true) {
  var x = 'g2'; 
  /** 
   * var 키워드는 함수 레벨 스코프를 스코프로 인정한다.
   * if 문 내부에 있는 x도 전역 변수로, 중복 선언 되었다.
   * 의도치 않게 변수 값이 변경된다.
   */
}
console.log(x); // 'g2'


// 예시2) 
// var
var a = '변경되지 않음.';

// for 문에서 선언된 a는 위에 선언된 지역 변수가 있으므로 중복 선언이다.
for (var a = 0; a < 5; a++) {
  console.log(a); // 0, 1, 2, 3, 4
}
console.log('>> ' + a); // 5, 전역 변수가 재할당 된다.

// let
let b = '변경되지 않음.';

for (let b = 0; b < 5; b++) {
  console.log(b); // 0, 1, 2, 3, 4
}
console.log('>> ' + b); // >> 변경되지 않음.
```

<br>

### 8. `렉시컬 스코프` 또는 `정적 스코프`
`어디에서 정의`했느냐가 상위 스코프를 결정한다.  

호출 위치는 상위 스코프 결정에 어떠한 영향도 주지 않는다.  
상위 스코프는 언제나 자신이 `정의`된 스코프이다.

```js
var x = 1;
function bar() {
  var x = 10;
  foo(); // foo 함수는 전역에서 정의되었으므로 전역 x를 참조한다.
}

function foo() {
  console.log(x);
}

foo(); // 1
bar(); // 1

```

<br>
<br>
<br>

---
## 14장 - 전역 변수의 문제점
### 1. 변수의 생명주기
* 생명주기
  1. 선언 (생성)
  2. 할당 (값을 갖음)
  3. 소멸 (메모리 공간에서 해제)
   
전역 변수: 런타임 이전에, 변수 선언은 선언문이 어디에 있든 상관없이 가장 먼저 실행된다.  
지역 변수: `함수 내부에서 선언한 변수`는 `함수가 호출된 직후`에 함수 몸체 코드가 실행되기 이전에 실행된다.

```js
function foo() {
    var x = 'local';
    console.log(x); // local
    return x;
}
foo();
console.log(x); // Uncaught ReferenceError: x is not defined
```
위 예제에서의 지역 변수의 생명주기는 아래와 같다.
```js
function foo() {
    /** 
     * var x = undefined; // 변수 x의 선언과 초기화.
     */
    // ----함수 몸체 코드가 실행되기 이전----

    x = 'local'; // 값의 할당.
    console.log(x); // local
    return x;
    // x 소멸.
}
foo();
console.log(x); // Uncaught ReferenceError: x is not defined
```

<br>

### 2. 전역 변수의 문제점
1. 암묵적 결합
     * 코드 어디서든 할당할 수 있는 변수를 사용하겠다는 뜻으로 암묵적 결합을 허용한다는 뜻.
2. 긴 생명주기
     * 전역 변수는 생명주기가 길어서 메모리 리소스를 오랜 기간 소비한다.
3. 스코프 체인 상에서 종점에 존재
      * 가장 마지막에 검색된다. 
4. 네임스페이스 오염
      * 파일이 분리되어 있어도 전역 스코프는 하나를 공유한다. 
<br>

### 3. 전역 변수의 문제점 억제하는 방법
1. 즉시 실행 함수 : 모든 코드를 즉시 실행으로 감싸면 모든 변수는 지역 변수가 된다. ex) 라이브러리
```js
(function() {
  var foo = 10; // 즉시 실행 함수의 지역변수.
}());

console.log(foo); // Uncaught ReferenceError: foo is not defined
```
2. 네임스페이스 객체 : 전역에 네임스페이스 객체를 생성하고 전역 변수처럼 사용하고 싶은 변수를 객체의 프로퍼티로 추가한다.   
-> 그러나 이 네임스페이스 객체도 전역 변수에 할당되므로 그다지 유용하지 않음.
```js
var MYAPP = {}; // 전역 네임스페이스 객체.

MYAPP.name = 'song';

console.log(MYAPP.name); // song

```
3. 모듈 패턴 : 클래스를 모방했다. 관련이 있는 변수와 함수를 모아 즉시 실행 함수로 감싸서 하나의 모듈을 만든다. 클로저를 기반으로 동작한다.  
* 모듈 패턴의 특징
  * 전역 변수의 억제
  * 캡슐화 

> 캡슐화? 객체의 상태를 나타내는 `프로퍼티`와 `메서드`를 하나로 묶는 것.  
> 정보 은닉? 캡슐화를 통해 특정 프로퍼티나 메서드를 감출 목적.

```js
var Counter = (function () {
  // private 변수
  var num = 0;

  // 외부에 노출하고 싶다면 반환해주면 됨.
  // 여기서는 메서드를 프로퍼티로 추가하여 객체로 반환했다.
  return {
    increase() {
      return ++num;
    },
    decrease() {
      return --num;
    }
  };
})();

console.log(Counter.num); // undefined
console.log(Counter.increase()); // 1
console.log(Counter.increase()); // 2
console.log(Counter.decrease()); // 1
console.log(Counter.decrease()); // 0

```
4. ES6 모듈 : 파일 자체의 독자적인 모듈 스코프를 제공한다.  
따라서 var 키워드는 더이상 전역 변수가 아니고, window 객체의 프로퍼티도 아니게 된다.  
`script`태그에 `type="module"` 어트리뷰트 추가. 확장자는 `.mjs`를 권장.
```html
<script type="module" src="00.01.index.mjs"></script>
<script type="module" src="00.02.myJs.mjs"></script>
```

<br>
<br>
<br>

---

## 15장 - let, const키워드와 블록 레벨 스코프
### 1. `var` 키워드의 문제점
1. 변수 중복 선언 허용
2. 함수 레벨 스코프
3. 변수 호이스팅
      ```js
      // ---런타임 이전---
      // foo = undefined
      // ----------------
      console.log(foo); // undefined

      foo = 123;
      var foo; 
      ```
   
### 2. `let` 
1. 변수 중복 선언 금지
2. `블록` 레벨 스코프
3. 변수 호이스팅
    * (호이스팅이 발생 하지만) 하지 않는 것처럼 동작한다.  
      : '선언'과 '초기화'가 동시에 진행되는 var와 달리,   
      let은 분리되어 진행되어 `참조 에러`가 발생한다. 

      ```js
      console.log(foo); // ReferenceError: foo is not defined

      let foo;
      console.log(foo); // undefined

      foo = 1;
      console.log(foo); // 1
      ```
4. 전역 객체의 프로퍼티가 아님.
   * `window.~` 로 접근할 수 없음.


### 3. `const`
1. 선언과 초기화를 동시에 해준다.
2. `블록` 레벨 스코프
3. `재할당 금지`
4. 상수 : 재할당이 금지된 변수. 대문자와 스네이크 케이스로 작성.  `const TAX_RATE = .1;`
5. `const 객체`
    * const 키워드는 `재할당이 금지`될 뿐, `불변하지는 않는다`.  
    * 변수에 할당된 참조 값은 변하지 않는다.  
    * 프로퍼티의 동적 생성, 삭제, 프로퍼티 값의 변경을 통해 객체는 변경할 수 있다.
      ```js
      const person = { // person에 할당된 객체의 참조값은 변하지 않음.
        name: 'song';
      }

      // 객체는 변경이 가능함. 재할당 없이 변경.
      person.name = 'kim';
      console.log(person); // {name: 'Kim'}
      ```


