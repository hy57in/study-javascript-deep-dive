# 26장 - ES6 함수의 추가 기능
## 함수의 구분
ES6 이전까지 js의 함수는 별다른 구분 없이 다양한 목적으로 사용되었다.  
- 일반적인 함수로도 호출
- `new` 연산자와 함께 인스턴스를 생성할 수 있는 생성자 함수
- 객체에 바인딩되어 메서드로서 호출  

편리할 것 같지만 실수를 유발시킬 수 있으며 성능 면에서도 손해가 많았다.  
ES6 이전까지 모든 함수는 `callable`(호출 할 수 있음) 이면서 `constructor`(인스턴스를 생성할 수 있음)였다.
때문에 객체에 바인됭 함수, 콜백 함수 또한 일반함수, 생성자 함수로도 호출이 가능하며 프로토타입 객체도 생생하게 된다.  

ES6 부터는 함수를 3가지 종류로 명확히 구분하였다.  
| ES6 함수의 구분   | constructor | prototype | super | argumets |
| -------------- | :---------: | :-------: | :---: | :------: |
| `일반 함수`      |      O   |     O     |   X   |    O     |
| `메서드`        |      X      |     X     |   O   |    O     |
| `화살표 함수`    |      X      |     X     |   X   |    X     |


<br />  


## ES6 메서드
ES6 이전에는 메서드에 대한 명확한 정의가 없었다. 일반적으로는 객체에 바인됭 함수를 일컫는 의미로 사용되었지만 ES6 사양에서 메서드에 대한 정의가 명확하게 규정되었다.  
ES6에서 메서드는 **메서드 축약 표현으로 정의된 함수를 의미**한다.  
ES6의 메서드는 몇가지 특징을 지닌다. 이 특징을 잘 숙지해야 보다 효율적인 코드를 구현할 수 있다.  

- 인스턴스를 생성할 수 없는 `non-constructor`
- 인스턴스를 생성할 수 없으므로 `prototype` 프로퍼티가 없고 프로토타입 객체도 생성X
- 표준 빌트인 객체가 제공하는 프로토타입 메서드와 정적 메서드는 모두 `non-constructor`  
- 자신을 바인딩한 객체를 가리키는 내부슬롯 `[[HomeObject]]`를 갖는다.  
    - super 참조는 이 내부슬롯을 사용하여 수퍼클래서의 메서드를 참조한다.
    - ES6 메서드가 아닌 함수는 이 내부슬롯을 가지지 않으므로 super 참조불가  

<br />  

```js
const obj = {
  x: 1,
  // foo는 메서드이다.
  foo() { return this.x; },
  // bar에 바인딩된 함수는 메서드가 아닌 일반 함수이다.
  bar: function() { return this.x; }
};

console.log(obj.foo()); // 1
console.log(obj.bar()); // 1
```  

<br />  

## ES6 화살표 함수  
`function` 키워드 대신 화살표를 사용하여 기존의 함수 정의 방식보다 간략하게 함수를 정의할 수 있다.  
표현 간략화 뿐만 아니라 내부 동작도 기존의 함수보다 간략하다.  

<br />  

**화살표 함수 정의 특징**
- 화살표 함수는 함수 선언문으로 정의할 수 없으며 표현식으로 정의해야한다.  
- IIFE(즉시실행 함수)로 사용가능하다.
- 일급 객체이므로 고차함수에 인수로 전달가능하다.
- 한줄(표현식인 문)이라면 `{}`를 생략가능하다.  

<br />  

**화살표 함수가 가지는 일반함수와의 차이**  
- 인스턴스를 생성할 수 없는 `non-constructor`이다.(메서드와 마찬가지)
- 중복된 매개변수 이름을 선언할 수 없다.
- 함수 자체에 `this`, `arguments`, `super`, `new.target` 바인딩을 갖지 않는다. 따라서 참조 시 스코프 체인을 통해 참조하게 된다.  

<br />  

### 화살표 함수에서의 `this`
콜백 함수 내부의 this와 콜백함수를 호출한 외부의 this와 다르기 때문에 발생하는 문제를 해결하기 위해 설계되었다.  

위에서 얘기했듯이 **화살표 함수는 this 바인딩을 갖지 않는다. 따라서 this 참조 시 상위 스코프의 this를 그대로 참조한다.(lexical this)**  즉, 화살표 함수의 this가 함수가 정의된 위치에 의해 결정된다는 것을 의미한다.(함수 선언시의 상위 스코프의 this)  

이로 인해 몇가지 주의할 점이 생긴다.  
- **객체 내 함수(일반적인 의미의 메서드) 정의 시**
  - 아래예제에서 person을 가리키지 않고 상위 스코프인 전역을 가리킴
  - 이때는 메서드 축약표현을 사용하자
  ```js
  // Bad
  const person = {
    name: 'Lee',
    sayHi: () => console.log(`Hi ${this.name}`)
  };

  // sayHi 프로퍼티에 할당된 화살표 함수 내부의 this는 상위 스코프인 전역의 this가 가리키는
  // 전역 객체를 가리키므로 이 예제를 브라우저에서 실행하면 this.name은 빈 문자열을 갖는
  // window.name과 같다. 전역 객체 window에는 빌트인 프로퍼티 name이 존재한다.
  person.sayHi(); // Hi
  ```
- **프로토타입 객체의 프로퍼티**
  - 이때도 위와 같은 문제 발생
  - 일반 함수를 사용하자 or 프로토타입 객체의 연결을 재설정하자
  ```js
  // Bad
  function Person(name) {
    this.name = name;
  }

  Person.prototype.sayHi = () => console.log(`Hi ${this.name}`);

  const person = new Person('Lee');
  // 이 예제를 브라우저에서 실행하면 this.name은 빈 문자열을 갖는 window.name과 같다.
  person.sayHi(); // Hi
  ```
- **클래스 필드 정의 제안**
  - 프로토타입 메서드가 아닌 인스턴스 메서드가 된다.
  - ES6 메서드를 사용하자
  ```js
  // Bad
  class Person {
    // 클래스 필드 정의 제안
    name = 'Lee';
    sayHi = () => console.log(`Hi ${this.name}`);
  }

  // 위와 같음
  class Person {
    constructor() {
      this.name = 'Lee';
      // 클래스가 생성한 인스턴스(this)의 sayHi 프로퍼티에 화살표 함수를 할당한다.
      // sayHi 프로퍼티는 인스턴스 프로퍼티이다.
      this.sayHi = () => console.log(`Hi ${this.name}`);
    }
  }


  const person = new Person();
  person.sayHi(); // Hi Lee
  ```

<br />  

## Rest 파라미터
Rest 파라미터(나머지 매개변수)는 매개변수 이름 앞에 세개의 점 `...`을 붙여서 정의한 매개변수를 의미한다.  
Rest 파라미터는 함수에 전달된 인수들의 목록을 배열로 전달받는다.  
- 매개변수에 할당된 인수를 제외한 나머지 인수들로 구성된 배열에 할당된다.
- 반드시 마지막 파라미터여야한다.
- 단 하나만 선언할 수 있다.
- 매개변수 개수를 나타내는 함수 객체의 length 프로퍼티에 영향을 주지 않는다.  

ES5에서는 가변인자 함수의 경우 매개변수를 통해 인수를 전달받는 것이 불가능 하므로 `arguments` 객체를 활용하여 인수를 전달받았다. 이 객체는 순회가능한 유사배열객체이며 함수 내부에서 지역변수처럼 사용할 수 있다.  
ES6에서는 둘 모두 사용할 수 있지만 화살표 함수의 경우 `arguments`객체를 갖지 않으므로 Rest 파라미터를 사용해야한다.  

<br />  

## 매개변수 기본값 
매개변수 기본값을 사용하면 함수 내에서 수행하던 인수 체크 및 초기화를 간소화할 수 있다.  
- 매개변수에 인수를 전달하지 않은 경우와 `undefined`를 전달한 경우에만 유효하다.
- Rest 파라미터에는 기본값을 지정하지 못한다.
- 함수 객체의 length 프로퍼티와 arguments객체에 아무런 영향을 주지 않는다.
```js
function logName(name = 'Lee') {
  console.log(name);
}

logName();          // Lee
logName(undefined); // Lee
logName(null);      // null
```

<br />
<hr>
<br />

# 27장 - 배열
배열은 여러개의 값을 순차적으로 나열한 자료구조이다.  
배열이 가지고 있는 값을 `요소`라고 부르고,  
배열의 요소는 배열에서 자신의 위치를 나태니는 `인덱스`를 가진다.  
또한 배열은 요소의 개수 즉, 배열의 길이를 나타내는 length 프로퍼티를 가진다.  

배열은 객체지만 일반객체와는 구별되는 몇가지 차이점이 있다. 바로 값의 순서를 가지고 있으며 length 프로퍼티가 있다는 것이다.  

<br />  

### js에서의 배열의 특징

**`자료구조에서의 배열`**  
자료구조에서 배우는 배열은 동일한 크기의 메모리 공간이 빈틈없이 연속적으로 나열된 자료구조를 말한다.  
즉, 데이터 타입이 통일되어 있으며 연속적으로 인접해 있다.( = 밀집 배열 )  
이는 임의의 접근에 O(1)의 시간복잡도를 가지고 있어 매우 효율적이며 빠르다. 하지만 배열 중간에 요소 삽입, 삭제의 경우 이후 요소들을 이동시켜야하기때문에 시간이 걸린다.  

<br />

**`js에서의 배열`**  
요소들이 동일한 크기를 갖지 않으며 메모리 구조상 연속적으로 이어져 있지 않을 수 있다.
이처럼 js 배열은 엄밀히 말하면 일반적인 의미의 배열과 다르다. 배열의 동작을 흉내낸 특수한 객체이다.  
**해시테이블로 구현한 객체**이기 때문에 요소 접근의 경우 일반배열보다 느릴 수 있지만 삽입, 삭제의 경우에 일반적인 배열보다 빠른 성능을 가진다.  
js엔진은 배열 요소 접근에 느릴 수 밖에 없다는 구조적인 단점을 보완하기 위해 최적화하여 구현하였다.(일반 객체보다는 빠르게 요소에 접근가능하다.)  

<br />  

**`length 프로퍼티 조작`**  
length 프로퍼티는 요소를 추가하거나 삭제하면 자동으로 갱신된다.  
하지만 직접 length 프로퍼티를 조작할 수 있는데, 현재 배열의 크기보다 작은 수를 할당한다면 배열의 뒷부분이 날라간다. 만약 현재 배열의 크기보다 큰 수를 할당한다면 배열의 길이가 늘어나지는 않는다(배열 뒤에 empty 가 추가됨. 뿐만아니라 배열 중간중간이 비어있을 수도 있음. - 희소배열)  

<br />  

**`지향하자`**  
js가 희소 배열을 허용하지만 희소배열은 사용하지 않는 것이 좋다.  
성능에도 좋지 않음, 연속적인 값의 집합이라는 배열의 의미와도 맞지 않다.
배열에는 같은 타입의 요소를 연속적으로 위치시키는 것이 최선이다.  

<br />  

### 배열 생성  

> 💡 유사 배열
배열처럼 인덱스로 프로퍼티 값에 접근할 수 있고, length 프로퍼티를 갖는 객체
마치 배열처럼 for 문으로 순회할 수 있다.  

1. 배열 리터럴
    ```js
    const arr = [1, 2, 3];
    console.log(arr.length); // 3
    ```
2. Array 생성자 함수
    - 전달된 인수가 한개라면 해당 크기만큼의 배열을 생성한다(희소배열로)
    - 인수가 두개 이상이거나 인수가 하나여도 숫자가 아니라면 전달받은 인수들로 배열을 만든다.
    - `new`를 사용하지 않아도 배열을 생성하는 함수로 동작한다.
    ```js
    const arr = new Array(10);
    console.log(arr); // [empty × 10]
    console.log(arr.length); // 10
    Array(1, 2, 3); // -> [1, 2, 3]
    ```
3. Array.of
    - ES6에서 도입되었으며 전달된 인수를 요소로 갖는 배열을 생성한다.
    ```js
    Array.of(1); // -> [1]
    Array.of(1, 2, 3); // -> [1, 2, 3]
    Array.of('string'); // -> ['string']
    ```
4. Array.from
    - 유사 배열 객체 or 이터러블 객체를 인수로 전달받아 배열로 변환하여 반환한다.
    - 두번째 인수로 콜백함수를 보낼 수 있다. 이 콜백함수는 두 가지 인자를 가지고 이 함수로 만들어지는 배열을 조작할 수 있다.(첫번째 인자는 만들어질 요소값, 두번째 인자는 인덱스)
    ```js
    // 유사 배열 객체를 변환하여 배열을 생성한다.
    Array.from({ length: 2, 0: 'a', 1: 'b' }); // -> ['a', 'b']

    // 이터러블을 변환하여 배열을 생성한다. 문자열은 이터러블이다.
    Array.from('Hello'); // -> ['H', 'e', 'l', 'l', 'o']
    ```    

<br />  

### 배열요소 다루기
1. 참조
    ```js
    const arr = [1, 2];

    // 인덱스가 0인 요소를 참조
    console.log(arr[0]); // 1
    // 인덱스가 1인 요소를 참조
    console.log(arr[1]); // 2
    // 인덱스가 2인 요소를 참조. 배열 arr에는 인덱스가 2인 요소가 존재하지 않는다.
    console.log(arr[2]); // undefined
    ```
2. 추가와 갱신
    - 인덱스를 사용해 값을 할당할 수 있다.
    - length 프로퍼티 값보다 큰 인덱스로 새로운 요소를 추가하면 희소배열이 된다.
    - 인덱스는 0 이상의 정수(또는 정수 형태의 문자열)을 사용해야한다. 그렇지 않으면 그냥 프로퍼티로 들어간다.(length에도 영향을 안줌)
      ```js
      const arr = [0];

      // 배열 요소의 추가
      arr[1] = 1;

      console.log(arr); // [0, 1]
      console.log(arr.length); // 2
      arr[100] = 100;

      console.log(arr); // [0, 1, empty × 98, 100]
      console.log(arr.length); // 101
      ```
3. 삭제
    - delete 연산자를 사용할 수 있지만 프로퍼티를 삭제하는 것이기때문에 희소배열이 된다.
    - splice 메서드를 이용하여 완전 삭제를 진행하자
      ```js
      // delete 연산자사용
      let arr = [1, 2, 3];

      // 배열 요소의 삭제
      delete arr[1];
      console.log(arr); // [1, empty, 3]
      // length 프로퍼티에 영향을 주지 않는다. 즉, 희소 배열이 된다.
      console.log(arr.length); // 3


      // splice 메서드 사용
      let arr = [1, 2, 3];
      // Array.prototype.splice(삭제를 시작할 인덱스, 삭제할 요소 수)
      // arr[1]부터 1개의 요소를 제거
      arr.splice(1, 1);
      console.log(arr); // [1, 3]

      // length 프로퍼티가 자동 갱신된다.
      console.log(arr.length); // 2
      ```  

### 배열 메서드  
정적 메서드와 프로토타입 메서드를 제공한다.
배열 메서드는 결과물을 반환하는 패턴이 두 가지이므로 주의가 필요하다.  
**원본 배열을 직접 변경하는 메서드와 원본 배열을 직접 변경하지 않고 새로운 배열을 생성하여 반환하는 메서드가 있다.**  
