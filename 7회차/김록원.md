# 26장 - ES6 함수의 추가 기능
## 함수의 구분
ES6 이전까지 js의 함수는 별다른 구분 없이 다양한 목적으로 사용되었다.  
- 일반적인 함수로도 호출
- `new` 연산자와 함께 인스턴스를 생성할 수 있는 생성자 함수
- 객체에 바인딩되어 메서드로서 호출  

편리할 것 같지만 실수를 유발시킬 수 있으며 성능 면에서도 손해가 많았다.  
ES6 이전까지 모든 함수는 `callable`(호출 할 수 있음) 이면서 `constructor`(인스턴스를 생성할 수 있음)였다.
때문에 객체에 바인됭 함수, 콜백 함수 또한 일반함수, 생성자 함수로도 호출이 가능하며 프로토타입 객체도 생생하게 된다.  

ES6 부터는 함수를 3가지 종류로 명확히 구분하였다.  
| ES6 함수의 구분   | constructor | prototype | super | argumets |
| -------------- | :---------: | :-------: | :---: | :------: |
| `일반 함수`      |      O   |     O     |   X   |    O     |
| `메서드`        |      X      |     X     |   O   |    O     |
| `화살표 함수`    |      X      |     X     |   X   |    X     |


<br />  


## ES6 메서드
ES6 이전에는 메서드에 대한 명확한 정의가 없었다. 일반적으로는 객체에 바인됭 함수를 일컫는 의미로 사용되었지만 ES6 사양에서 메서드에 대한 정의가 명확하게 규정되었다.  
ES6에서 메서드는 **메서드 축약 표현으로 정의된 함수를 의미**한다.  
ES6의 메서드는 몇가지 특징을 지닌다. 이 특징을 잘 숙지해야 보다 효율적인 코드를 구현할 수 있다.  

- 인스턴스를 생성할 수 없는 `non-constructor`
- 인스턴스를 생성할 수 없으므로 `prototype` 프로퍼티가 없고 프로토타입 객체도 생성X
- 표준 빌트인 객체가 제공하는 프로토타입 메서드와 정적 메서드는 모두 `non-constructor`  
- 자신을 바인딩한 객체를 가리키는 내부슬롯 `[[HomeObject]]`를 갖는다.  
    - super 참조는 이 내부슬롯을 사용하여 수퍼클래서의 메서드를 참조한다.
    - ES6 메서드가 아닌 함수는 이 내부슬롯을 가지지 않으므로 super 참조불가  

<br />  

```js
const obj = {
  x: 1,
  // foo는 메서드이다.
  foo() { return this.x; },
  // bar에 바인딩된 함수는 메서드가 아닌 일반 함수이다.
  bar: function() { return this.x; }
};

console.log(obj.foo()); // 1
console.log(obj.bar()); // 1
```  

<br />  

## ES6 화살표 함수  
`function` 키워드 대신 화살표를 사용하여 기존의 함수 정의 방식보다 간략하게 함수를 정의할 수 있다.  
표현 간략화 뿐만 아니라 내부 동작도 기존의 함수보다 간략하다.  

<br />  

**화살표 함수 정의 특징**
- 화살표 함수는 함수 선언문으로 정의할 수 없으며 표현식으로 정의해야한다.  
- IIFE(즉시실행 함수)로 사용가능하다.
- 일급 객체이므로 고차함수에 인수로 전달가능하다.
- 한줄(표현식인 문)이라면 `{}`를 생략가능하다.  

<br />  

**화살표 함수가 가지는 일반함수와의 차이**  
- 인스턴스를 생성할 수 없는 `non-constructor`이다.(메서드와 마찬가지)
- 중복된 매개변수 이름을 선언할 수 없다.
- 함수 자체에 `this`, `arguments`, `super`, `new.target` 바인딩을 갖지 않는다. 따라서 참조 시 스코프 체인을 통해 참조하게 된다.  

<br />  

### 화살표 함수에서의 `this`
콜백 함수 내부의 this와 콜백함수를 호출한 외부의 this와 다르기 때문에 발생하는 문제를 해결하기 위해 설계되었다.  

위에서 얘기했듯이 **화살표 함수는 this 바인딩을 갖지 않는다. 따라서 this 참조 시 상위 스코프의 this를 그대로 참조한다.(lexical this)**  즉, 화살표 함수의 this가 함수가 정의된 위치에 의해 결정된다는 것을 의미한다.(함수 선언시의 상위 스코프의 this)  

이로 인해 몇가지 주의할 점이 생긴다.  
- **객체 내 함수(일반적인 의미의 메서드) 정의 시**
  - 아래예제에서 person을 가리키지 않고 상위 스코프인 전역을 가리킴
  - 이때는 메서드 축약표현을 사용하자
  ```js
  // Bad
  const person = {
    name: 'Lee',
    sayHi: () => console.log(`Hi ${this.name}`)
  };

  // sayHi 프로퍼티에 할당된 화살표 함수 내부의 this는 상위 스코프인 전역의 this가 가리키는
  // 전역 객체를 가리키므로 이 예제를 브라우저에서 실행하면 this.name은 빈 문자열을 갖는
  // window.name과 같다. 전역 객체 window에는 빌트인 프로퍼티 name이 존재한다.
  person.sayHi(); // Hi
  ```
- **프로토타입 객체의 프로퍼티**
  - 이때도 위와 같은 문제 발생
  - 일반 함수를 사용하자 or 프로토타입 객체의 연결을 재설정하자
  ```js
  // Bad
  function Person(name) {
    this.name = name;
  }

  Person.prototype.sayHi = () => console.log(`Hi ${this.name}`);

  const person = new Person('Lee');
  // 이 예제를 브라우저에서 실행하면 this.name은 빈 문자열을 갖는 window.name과 같다.
  person.sayHi(); // Hi
  ```
- **클래스 필드 정의 제안**
  - 프로토타입 메서드가 아닌 인스턴스 메서드가 된다.
  - ES6 메서드를 사용하자
  ```js
  // Bad
  class Person {
    // 클래스 필드 정의 제안
    name = 'Lee';
    sayHi = () => console.log(`Hi ${this.name}`);
  }

  // 위와 같음
  class Person {
    constructor() {
      this.name = 'Lee';
      // 클래스가 생성한 인스턴스(this)의 sayHi 프로퍼티에 화살표 함수를 할당한다.
      // sayHi 프로퍼티는 인스턴스 프로퍼티이다.
      this.sayHi = () => console.log(`Hi ${this.name}`);
    }
  }


  const person = new Person();
  person.sayHi(); // Hi Lee
  ```

<br />  

## Rest 파라미터
Rest 파라미터(나머지 매개변수)는 매개변수 이름 앞에 세개의 점 `...`을 붙여서 정의한 매개변수를 의미한다.  
Rest 파라미터는 함수에 전달된 인수들의 목록을 배열로 전달받는다.  
- 매개변수에 할당된 인수를 제외한 나머지 인수들로 구성된 배열에 할당된다.
- 반드시 마지막 파라미터여야한다.
- 단 하나만 선언할 수 있다.
- 매개변수 개수를 나타내는 함수 객체의 length 프로퍼티에 영향을 주지 않는다.  

ES5에서는 가변인자 함수의 경우 매개변수를 통해 인수를 전달받는 것이 불가능 하므로 `arguments` 객체를 활용하여 인수를 전달받았다. 이 객체는 순회가능한 유사배열객체이며 함수 내부에서 지역변수처럼 사용할 수 있다.  
ES6에서는 둘 모두 사용할 수 있지만 화살표 함수의 경우 `arguments`객체를 갖지 않으므로 Rest 파라미터를 사용해야한다.  

<br />  

## 매개변수 기본값 
매개변수 기본값을 사용하면 함수 내에서 수행하던 인수 체크 및 초기화를 간소화할 수 있다.  
- 매개변수에 인수를 전달하지 않은 경우와 `undefined`를 전달한 경우에만 유효하다.
- Rest 파라미터에는 기본값을 지정하지 못한다.
- 함수 객체의 length 프로퍼티와 arguments객체에 아무런 영향을 주지 않는다.
```js
function logName(name = 'Lee') {
  console.log(name);
}

logName();          // Lee
logName(undefined); // Lee
logName(null);      // null
```

<br />
<hr>
<br />

# 27장 - 배열